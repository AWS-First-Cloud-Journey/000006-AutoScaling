[
{
	"uri": "/vi/1-introduction/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Giới thiệu Trong bài thực hành này, chúng ta sẽ tiến hành triển khai ứng dụng sử dụng Auto Scaling Group để đảm bảo khả năng mở rộng linh hoạt theo nhu cầu của người dùng. Chúng ta cũng sẽ triển khai Load Balancer để cân bằng tải và phân phối yêu cầu truy cập từ người dùng đến Application Tier.\nHãy đảm bảo bạn đã tham khảo tài liệu Triển khai Ứng dụng FCJ Management trên Máy ảo Windows/AmazonLinux và hiểu cách triển khai ứng dụng trên máy ảo. Chúng ta sẽ sử dụng máy ảo FCJ Management đã triển khai để thực hiện việc triển khai và mở rộng trong Auto Scaling Group.\nAuto Scaling Group Tại sao cần sử dụng Auto scaling group?\nKhi ứng dụng của chúng ta đưa vào hoạt động, lượng người truy cập sẽ thay đổi theo thời gian, do đó chúng ta cần thường xuyên thay đổi (scaling) lượng instance nhằm nâng cao tính sẵn sàng và tiết kiệm chi phí. Để tự động hóa và linh hoạt trong công việc scaling, chúng ta sẽ có giải pháp là Auto scaling group.\nSơ lược về Auto scaling group\nAuto Scaling Group (ASG) giúp tự động điều chỉnh số lượng EC2 instances theo nhu cầu của ứng dụng. ASG có thể tự động mở rộng (scale up) khi lưu lượng tăng, hoặc thu nhỏ (scale down) khi lưu lượng giảm, giúp tối ưu hóa tài nguyên và giảm chi phí. Nó cũng giúp đảm bảo tính sẵn sàng cao bằng cách phân phối instances qua nhiều Availability Zones để duy trì hoạt động liên tục ngay cả khi một phần của hệ thống gặp sự cố.\nCác loại Scaling trong ASG\nTrong nội dung này, chúng ta sẽ tìm hiểu về các loại Scaling sau đây:\nManual Scaling: Người dùng tự tay điều chỉnh số lượng EC2 instances trong Auto Scaling Group dựa trên yêu cầu. Đây là phương pháp thủ công, không tự động dựa trên chỉ số cụ thể. Dynamic Scaling: Tự động điều chỉnh số lượng instances dựa trên các chỉ số thời gian thực như CPU utilization, network traffic, hoặc custom metrics từ CloudWatch. Dynamic scaling có 3 chính sách chính là Target Tracking Scaling, Step Scaling, Simple Scaling. Scheduled Scaling: Cho phép chúng ta cấu hình các thời gian cụ thể để tự động mở rộng hoặc thu nhỏ instances, ví dụ như tăng số lượng instances vào giờ cao điểm hoặc giảm xuống ngoài giờ làm việc. Phù hợp cho các trường hợp mà chúng ta đã biết trước mô hình lưu lượng truy cập. Predictive Scaling: Nó dự đoán hoạt động bằng cách phân tích load data trong lịch sử để tìm các mẫu hàng ngày hoặc hàng tuần trong luồng lưu lượng truy cập. Nó sử dụng thông tin này để dự báo nhu cầu công suất trong tương lai để Amazon EC2 Auto Scaling có thể chủ động tăng công suất của Auto Scaling group để phù hợp với dự kiến. Launch Template Launch Template là một cấu hình chứa các thông số cần thiết để khởi chạy EC2 instances. Nó lưu trữ các chi tiết như loại instance, AMI (Amazon Machine Image), key pair, network settings, security groups, và các thông tin khác về cấu hình của EC2. Nhằm đơn giản hóa việc tạo instance, hỗ trợ trong việc tự động tạo mới các instance trong ASG.\nElastic Load Balancer Elastic Load Balancer là một công cụ giúp phân phối đều tải công việc (traffic) đến nhiều máy chủ hoặc instances để đảm bảo hệ thống hoạt động ổn định và tránh quá tải cho bất kỳ một máy chủ nào. Nó giúp tối ưu hiệu suất, tăng tính sẵn sàng và đảm bảo rằng nếu một máy chủ gặp sự cố, lưu lượng sẽ được chuyển hướng tới các máy chủ khác mà không ảnh hưởng đến người dùng.\nTarget Group Target Group là một thành phần của Elastic Load Balancer (ELB), dùng để xác định và quản lý các EC2 instances mà Load Balancer sẽ phân phối lưu lượng truy cập đến.\n"
},
{
	"uri": "/vi/7-test-solutions/7.1-test-manual-scaling-solution/",
	"title": "Kiểm thử giải pháp manual scaling",
	"tags": [],
	"description": "",
	"content": "Manual Scaling Manual Scaling là mình sẽ thực hiện bằng cách là tự điều chỉnh thủ công thông số Desired capacity của ASG, sau khi điều chỉnh xong và xác nhận update thì đợi trong một khoảng thời gian, ASG sẽ update xong số lượng và tiến hành khởi tạo hoặc xoá bớt đi EC2 Instance tuỳ thuộc vào thông số Desired capacity đó.\nCài đặt kiểm thử Khi tạo xong Auto Scaling Group, thì chính dịch vụ này sẽ tự động khởi tạo một EC2 Instance do chúng ta cấu hình trước đó, để có thể xem được điều này thì chúng ta có thể vào trong EC2 Console\nChọn Load Balancer Chọn tab Resource map - new Ở đây chúng ta có thể thấy được là Target Group trước đó đang có liên kết tới 2 Targets lần lượt là 2 EC2 Instances (1 là instance gốc được tạo trước đó; cái còn lại là instance được tạo từ ASG).\nGiờ thì kiểm thử với ứng dụng mà chúng ta đã tải trước đó.\nMở ứng dụng lên, ấn vào tab Test Type Test Type: Chọn CLICKS Run until: 100000 User Simulation Number Of Users: 1000 Click Delay: 1 seconds Trong tab URLs, mình sẽ cấu hình các thông tin\nName: Manual Scaling Test, ở đây thì bạn đặt là gì cũng được, bởi vì chúng ta sẽ dùng để test trong các loại scaling khác sau đó. URL: copy DNS của Load Balancer và dán vào. Trên thanh công cụ, mình sẽ bắt đầu ấn Start Test.\nTiến hành kiểm thử Giờ quay lại với AWS Management Console, vào trong EC2 Console\nTích chọn 2 EC2 Instance ở trong target group Ấn vào tab Monitoring và bắt đầu quan sát Trong mục này, chúng ta có 7 biểu đồ, nhưng hiện tại thì chúng ta chỉ quan tâm tới 5 biểu đồ sau:\nCPU Utilization (%): biểu đồ cho thấy lượng tài nguyên CPU mà 2 instances này đã dùng trong khoảng dưới 8% với mỗi instance. Network in (bytes): biểu đồ cho thấy dung lượng mạng đi vào 2 instances này trong khoảng dưới 2.9 triệu Megabytes với mỗi instance. Network out (bytes): biểu đồ cho thấy dung lượng mạng đi ra từ 2 instances này trong khoảng dưới 17.3 triệu Megabytes với mỗi instance. Network packets in (count): biểu đồ cho thấy số lượng các gói tin đi vào 2 instances này trong khoảng dưới 6.85 nghìn gói tin với mỗi instance. Network packets out (count): biểu đồ cho thấy số lượng các gói tin đi ra từ 2 instances này trong khoảng dưới 7.36 nghìn gói tin với mỗi instance. Từ giờ trở đi chúng ta sẽ đọc các biểu đồ này như vậy. Bao gồm các thông số quan trọng ở cột dọc, cột ngang và các đường vẽ. Từ đây sẽ giúp chúng ta hiểu hơn về cách Load Balancer cân bằng lưu lượng mạng tới cho các instance ở trong Target Group.\nVà nếu như mà bạn chỉ tích chọn 1 instance, thì trên biểu đồ chỉ có một đường vẽ đại diện cho instance đó. Như vậy, khi tích chọn càng nhiều trên danh sách thì sẽ càng có nhiều đường biểu diễn hơn.\nĐiều chính thủ công thông số Desired capacity của ASG Giờ thì chúng ta trở lại với trang thông tin chi tiết của ASG mà chúng ta đã tạo ở trước đó. Trong phần Group details, chúng ta có thể thấy được là: Desired capacity = 1.\nGiờ chúng ta sẽ giả sử một tình huống, là đã qua giờ cao điểm nên là mình muốn tắt bớt đi một instance để tiết kiệm chi phí. Để làm được việc này thì chúng ta sẽ điều chỉnh thủ công thông số Desired capacity = 0. Ấn Edit.\nSẽ hiện lên bảng thông tin Group size, điều chỉnh Desired capacity và Min desired capacity về 0 và ấn Update.\nSau đó vào trong tab Activity để xem ASG đang có hoạt động gì.\nTrong quá trình instance đang được tắt đi, thì bạn có thể dừng chương trình test lại.\n=\u0026gt; Như vậy chúng ta có thể thấy là ASG sẽ tự động huỷ đi một instance theo như thông số mà nó đã được cấu hình.\nMột vài phút sau, vào lại trong trang thông tin của Load Balancer, vào tab Resource map - new thì chúng ta có thể thấy được là giờ chỉ còn có một target thôi.\nTới bước này thì bạn NHỚ BẬT LẠI chương trình test.\nChúng ta cũng sẽ nhận được một email từ SNS\nKhi chương trình của chúng ta đang có lưu lượng truy cập lớn, thì thao tác sẽ bị chậm đi một ít. Các bạn có thể mở ứng dụng thông qua DNS của Load Balancer để kiểm thử.\nGiờ thì vào lại EC2 Console, chọn target còn lại, và quan sát biểu đồ.\nCó thể thấy, hiện tại thì instance đã chịu tải lưu lượng mạng vào và ra có thể nói là gấp đôi và lượng tài nguyên CPU đã dùng gần gấp 4 lần.\nKết luận Trên thực tế thì các hệ thống sẽ có các bước thực hiện phức tạp hơn, lâu hơn nên từ đó sẽ dùng nhiều tài nguyên CPU hơn. Trong bài này thì chúng ta chỉ kiểm tra giao thực GET, còn thực tế thì các request này sẽ phức tạp hơn nhiều.\n"
},
{
	"uri": "/vi/4-setup-load-balancer/4.1-create-target-group/",
	"title": "Tạo Target Group",
	"tags": [],
	"description": "",
	"content": "Tạo Target Group Ở phần giao diện quản lý EC2, ở bảng chọn bên phải, hãy kéo dưới dưới phần Load Balancing\nChọn Target Group Chọn Create target group Xuất hiện bảng Specify group details, hãy cấu hình theo như sau.\nỞ phần Basic configuration Choose a target types Instances Target group name FCJ-Management-TG Tiếp tục trong phần Basic configuration Protocol : port HTTP, 5000 IP address IPv4 VPC AutoScaling-Lab Protocol version HTTP1 Nhấn Next Tiếp theo chúng ta tiến hành Register target\nỞ phần Available instance\nChọn targer group FCJ-Management-TG Ports for the seleced instances 5000 Chọn Include as pending below Ở phần Review targets Ta sẽ thấy target group đã được đăng ký trước đó Chọn Create target group Kết quả Chúng ta đã hoàn thành việc tạo Target Group, chọn Target Group FCJ-Management-TG vừa khởi tạo để xem thông tin.\n"
},
{
	"uri": "/vi/2-preparation/2.1-setup-network/",
	"title": "Thiết lập hạ tầng mạng",
	"tags": [],
	"description": "",
	"content": "Tạo VPC Truy cập vào AWS Management Console\nTìm VPC Chọn VPC Trong giao diện VPC\nChọn Create VPC Trong giao diện Create VPC\nChọn VPC and more Name, nhập tên VPC của bạn. Trong bài lab này, ta đặt tên là AutoScaling-Lab IPv4 CIDR block, nhập 10.0.0.0/16 Chọn theo hướng dẫn\nSố lượng AZ là 3 Số lượng public subnet là 3 Số lượng private subnet là 3 Nat gateways chọn None Chọn theo hướng dẫn\nVPC endpoints chọn None Chọn Create VPC Thực hiện cấp phát IP public. Thực hiện cấp phát IP public.\nChọn Subnets Chọn public subnet Chọn Edit subnet settings Chọn Enable auto-assign public IPv4 address. Sau đó Chọn Save\nKiểm tra đã cấp phát thành công.\nThực hiện cấp phát cho Public subnet còn lại (làm tương tự). Tiếp theo chúng ta sẽ tạo Security group cho ứng dụng.\nTrong giao diện VPC, chọn Security groups Chọn Create security group Thực hiện cấu hình Security Group\nSecurity group name, nhập FCJ-Management-SG Description, nhập Security Group for FCJ Management VPC,thì chọn VPC vừa tạo: AutoScaling-Lab. Cấu hình Inbound rules\nĐầu tiên phải cấu hình SSH port 22 và Source: MyIP để có thể truy cập vào instance. Tiếp theo là HTTP port 80. Custom TCP port 5000 dành cho FCJ Management HTTPS port 443. Kiểm tra Outbound rules và chọn Create security group\nTạo Security group cho Database instance Chúng ta tạo Security group cho Database instance. Để đảm bảo bảo mật nên không cấu hình chung Security group của ứng dụng. Cấu hình security group\nSecurity Group name, nhập FCJ-Mangement-DB-SG Description, nhập Security Group for DB instance Chọn vpc vừa tạo Cấu hình Inbound rules\nChọn Add rule Chọn MYSQL/Aurora port 3306 Sau đó chọn Soure là FCJ-Management-SG Kiểm tra lại Outbound rules và cuối cùng bấm Create security group\n"
},
{
	"uri": "/vi/",
	"title": "Triển khai ứng dụng FCJ Management với Auto Scaling Group",
	"tags": [],
	"description": "",
	"content": "Triển khai ứng dụng FCJ Management với Auto Scaling Group Tổng quan Trong hướng dẫn này, chúng ta sẽ thực hiện triển khai ứng dụng bằng cách sử dụng Auto Scaling Group để đảm bảo khả năng mở rộng linh hoạt theo nhu cầu của người truy cập. Ngoài ra, chúng ta cũng sẽ triển khai Load Balancer để cân bằng tải và phân phối yêu cầu từ người dùng đến Application Tier của ứng dụng.\nHãy đảm bảo bạn đã xem qua tài liệu Triển khai Ứng dụng FCJ Management trên Máy ảo Windows/AmazonLinux để nắm vững cách triển khai ứng dụng trên máy ảo. Chúng ta sẽ cần sử dụng máy ảo FCJ Management đã triển khai để thực hiện việc triển khai đồng loạt và mở rộng trong Auto Scaling Group.\nNội dung Giới thiệu Các bước chuẩn bị Khởi tạo Template Thiết lập Load Balancer Kiểm thử Khởi tạo Auto Scaling Group Kiểm thử các giải pháp Dọn dẹp tài nguyên "
},
{
	"uri": "/vi/2-preparation/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Trong bài thực hành này, chúng ta cần chuẩn bị một số dịch vụ để có thể tiến hành triển khai ứng dụng FCJ Management sử dụng Auto Scaling Group cùng với Elastic Load Balancer. Một cách tổng quan, chúng ta sẽ triển khai ứng dụng FCJ Management theo kiến trúc như sau: Nội dung Thiết lập hạ tầng mạng Khởi tạo EC2 instance Khởi tạo Database instance với RDS Cài đặt dữ liệu cho database Triển khai máy chủ web Chuẩn bị metric cho Predictive scaling "
},
{
	"uri": "/vi/2-preparation/2.2-launch-ec2-instance/",
	"title": "Khởi tạo EC2 Instance",
	"tags": [],
	"description": "",
	"content": "Truy cập vào AWS Management Console:\nTìm EC2 Chọn EC2 Trong giao diện EC2:\nChọn Launch instances Đặt tên cho instance, nhập FCJ-Management\nThực hiện chọn AMI:\nChọn Quick Start Chọn Amazon Linux Chọn Amazon Linux 2023 AMI Chọn Instance type:\nChọn t2.micro Chọn Create new key pair Cấu hình key pair\nĐặt tên là fcj-key Key pair type: RSA Private key format: .pem Bấm Create key pair Thực hiện cấu hình Network:\nBấm vào nút Edit\nVPC, chọn VPC đã tạo.\nSubnet, chọn Public subnet\nKiểm tra đã Auto-assign public IP chưa?. Nếu chưa, xem lại bước cấp phát public IP ở bước tạo VPC.\nTiếp tục:\nChọn Select existing security group rồi chọn FCJ-Management-SG. Chọn Launch instance. Khởi tạo instance thành công.\n"
},
{
	"uri": "/vi/7-test-solutions/7.2-test-scheduled-scaling-solution/",
	"title": "Kiểm thử giải pháp scheduled scaling",
	"tags": [],
	"description": "",
	"content": "Scheduled Scaling Scheduled Scaling là mình sẽ cho ASG biết là khi nào, khoảng thời gian nào là nó nên khởi tạo thêm các instance và thời điểm nào là nó nên xoá bớt đi các instance. Loại scale này phù hợp cho các lượng công việc mà trong đó nó sẽ biến động theo một khoảng thời gian nhất định, có tính chất lặp lại từng ngày và trong một khoảng thời gian dài.\nVì ở phần trước thì chúng ta đã cài đặt phần kiểm thử rồi, nên giớ chúng ta sẽ không cần phải cài đặt lại nữa, tiếp tục dùng các thông số cài đặt đó.\nTiến hành cấu hình Vào trong trang thông tin của ASG đã tạo, vào tab Automatic scaling, kéo xuống dưới cùng.\nỞ dưới phần Scheduled actions, ấn Create scheduled action\nMột biểu mẫu sẽ hiện lên, điền các thông tin như sau\nName: Rush hour. Desired capacity: 1. Min: 1 (các bạn nên để là 0). Max: 3. Recurrence: Once (hoặc bất kì lựa chọn nào khác). Time zone: Asia/Ho_Chi_Minh. Specific start time: nên chỉnh thời gian gần nhất với lúc mà bạn đang cấu hình. Ấn Create để tạo. Các thông số Desired capacity, Min hay Max nó đều sẽ ảnh hưởng tới các thông số tương ứng của ASG, nên trên thực tế thì chúng ta cũng sẽ cần phải kết hợp nhiều loại scaling và cân nhắc, xem xét kĩ lưỡng khi cấu hình các thông số này.\nĐã tạo thành công.\nKiểm thử Trước khi ASG khởi tạo instance theo lịch khoảng 5 phút, thì chúng ta nên chạy chương trình test.\nSau một vài phút, thời điểm ASG khởi tạo instance mới đã tới. Lúc này vào trong tab Activity để xem các hoạt động của ASG. Có thể thấy là sự kiện Executing scheduled action Rush hour được khởi động vào đúng thời điểm và sau đó thì ASG khởi tạo instance mới.\nTrở lại với EC2 Console, các metrics sẽ được cập nhật vào mỗi 15 phút một lần, nên khi quay lại để quan sát các thông số này, tập chung vào biểu đồ CPU Utilization, thì chúng ta có thể thấy là từ khoảng 14:30 tới 14:40 thì có một đoạn bị gấp khúc và tăng cao, đó là khi mà chung ta mở chương trình test.\nĐợt tiếp thêm vài phút để các metric này được cập nhật, khi được cập nhật thì tích chọn thêm instance vừa mới được khởi tạo.\nChúng ta có thể thấy là sau khúc 14:40 thì đường biểu đồ đã đi xuống.\nPhóng to biểu đồ này lên\nChọn 1h Chọn 1 second Chúng ta sẽ thấy rõ hơn về sự thay đổi.\nKết luận Trong thực tế thì các sàn giao dịch thường sẽ có các thời điểm mà lượng người dùng sẽ tăng cao. Và việc tăng cao này nó giống như giờ cao điểm ở giao thông, cứ vào một khoảng thời điểm nhất định nào đó thì lượng người tham gia giao thông / giao dịch sẽ tăng cao, việc này sẽ lặp lại vào mỗi ngày trong một thời gian dài. Khi đó thì mình sẽ cần lên lịch cho các instance mới để chịu tải.\nNhưng trong thực tế thì chúng ta cần sẽ phải kết hợp với các loại scaling khác để tăng độ tin cậy của hệ thống.\n"
},
{
	"uri": "/vi/4-setup-load-balancer/4.2-create-load-balancer/",
	"title": "Tạo Load Balancer",
	"tags": [],
	"description": "",
	"content": "Tạo Load Balancer Ở giao diện quản lý EC2, ở bảng chọn bên trái\nChọn Load Balancers Nhấn vào nút Create Load Balancer Xuất hiện bảng Compare and select load balancer type\nỞ phần Load balancer types Ở phàn Application Load Balancer Chọn Create Chúng ta sẽ thấy xuất hiện bảng Create Application Load Balancer\nỞ phần Basic configuration Load balancer name FCJ-Management-LB Scheme Internet-facing Load balancer IP address type IPv4 Ở phần Network mapping Chọn VPC AutoScaling-Lab Chọn Subnet Public ap-southeast-1a, ap-southeast-1b, ap-southeast-1c. Lưu ý chọn public subnet Ở phần Security groups Security groups FCJ-Management-SG Ở phần Listeners and routing Default action FCJ-Management-TG Ở phần Summary, chúng ta có thể kiểm tra được các thông tin đã cấu hình cho Load Balancer Nhấn vào nút Create Balancer Kết quả Sau khi tạo Load Balancer chúng ta chọn FCJ-Management-LB để xem thông tin\nTrong phần quản lý Load Balancer đã tạo Chọn Resource map - new để xem tổng quan liên kết của Load Balancer "
},
{
	"uri": "/vi/2-preparation/2.3-launch-db-instance/",
	"title": "Khởi tạo Database Instance với RDS",
	"tags": [],
	"description": "",
	"content": "Tạo Subnet group cho Database instance Truy cập vào AWS Management Console\nTìm RDS Chọn RDS Tiếp tục:\nChọn Subnet groups Chọn Create DB subnet group Trong giao diện Create DB subnet group\nName, nhập FCJ-Management-Subnet-Group Description, nhập Subnet Group for FCJ Management Chọn VPC đã tạo. Tiến hành cấu hình subnet\nChọn các AZ Chọn các Private subnet Chọn Create\nThành công tạo DB Subnet Group với 2 AZ\nTạo Database instance Truy cập vào RDS AWS Management Console\nChọn Databases Chọn Create database Chọn phương thức tạo database\nChọn Standard create Cấu hình Engine database\nChọn MySQL Cấu hình Template\nChọn Production Chọn Mutil-AZ DB instance Tiếp theo, thực hiện cài đặt chi tiết\nDB instance identifier, nhập fcj-management-db-instance Master username, nhập admin Chọn sang Self managed Tiếp tục: - Master password, nhập tùy ý của bạn (trong bài lab, nhập 123Vodanhphai) - Confirm password, nhập lại password 1 lần nữa.\nCấu hình chi tiết cho instace\nChọn db.m5d.large Chọn General Purpose SSD (gp3) Allocated storage nhập vào 20 Thực hiện cấu hình Connectivity cho db instance\nChọn Don\u0026rsquo;t connect to an EC2 compute resouce VPC, chọn AutoScaling-Lab đã tạo Subnet group, chọn subnet group đã tạo. Tiếp tục:\nVPC security group, Chọn Choose existing Security Group, chọn FCJ-Management-DB-SG (tránh nhầm lẫn với SG của web). Khởi tạo Initial Database với tên awsfcjuer, còn lại để mặc định.\nBấm Create database\nDatabase instance đã được tạo thành công.\nChúng ta có được Endpoint và Port như dưới đây.\n"
},
{
	"uri": "/vi/7-test-solutions/7.3-test-dynamic-scaling-solution/",
	"title": "Kiểm thử giải pháp dynamic scaling",
	"tags": [],
	"description": "",
	"content": "Dynamic Scaling Dynamic scaling là dạng mà nó sẽ dựa vào các metric được cung cấp bởi CloudWatch, khi này thì tuỳ thuộc vào việc mà chúng ta cấu hình thì nó sẽ khởi tạo và huỷ instance đi. Chúng ta có thể cấu hình sao cho ASG sẽ mở một instance mới khi tài nguyên CPU của instance hoặc các instance ở trên mức 90% hoặc là lưu lượng mạng và và ra lớn hoặc là số các gói tin gửi tới từng instance là lớn.\nTuỳ vào hệ thống và tính chất thì chúng ta sẽ cấu hình khác đi. Trong bài này, chúng ta sẽ cấu hình theo dạng \u0026ldquo;số lượng các gói tin được gửi tới từng instance\u0026rdquo;.\nTiến hành cấu hình Trước khi kiểm thử, thì mình sẽ tiến hành scale in thủ công, giảm bớt đi một instance, khi đó thì vào trong tab Activity và kiểm tra lại.\nSau khi đã xoá xong thì giờ chúng ta sẽ cấu hình Dynamic. Vào trong tab Automatic scaling\nẤn Create dynamic scaling policy để tạo chính sách scaling tự động mới. Trong biểu mẫu này thì chúng ta sẽ điền các thông số như sau:\nPolicy type: Target tracking scaling. Scaling policy name: Request Over 500 per target. Metric type: Application Load Balancer request count per target. Target group: FCJ-Management-TG. Target value: 500 (requests). Instance warmup: 60 seconds (nên để số lớn hơn). Ấn Create để tạo. Thông số Instance warmup sẽ ảnh hưởng tới thời gian mà instance sẽ bắt đầu nhận các lưu lượng từ bên ngoài vào. Cụ thể là khi mà một instance được tạo và và trong trạng thái InSeriver (sẵn sàng để hoạt động) thì chúng ta có thể điều chỉnh khoảng thời gian để một instance bắt đầu nhận và xử lý các requests từ bên ngoài, khoảng thời gian đó gọi là instance warmup. Việc điều chỉnh thông số này là để kéo thêm thời gian cho instance đi vào hoạt động ổn định hoàn toàn, vì ứng dụng cần phải cập nhật và cài đặt các phụ thuộc khác cũng như là kết nối tới các dịch vụ khác để có thể hoạt động bình thường.\nKết quả\nKiểm thử Bắt đầu chạy chương trình kiểm thử\nVào trong EC2 Console để xem lưu lượng request tới EC2 là bao nhiêu\nChờ một xíu để metrics được cập nhật và chúng ta có thể thấy là các biểu đồ có xu hướng đi lên và đi ngang.\nVào lại trong tab Activity của ASG, chúng ta sẽ thấy có 3 instances được tạo. Bởi vì lượng request là rất lớn, nên ASG tính toán được là nó cần sẽ phải tạo tối đa số instances mong muốn.\nTrở lại với EC2 Console, tích chọn tất cả các instances được tạo ra, và quan sát các biểu đồ\nChúng ta sẽ thấy được là đường màu xanh đang dần đi xuống, và các đường khác đang dần được hiện ra.\nNhư mình đã nói ở phần trước thì các thông số sẽ được cập nhật khoảng 15 phút một lần, vì thế mà bạn sẽ cần phải chờ một khoảng thời gian để thấy được kết quả.\nGiờ thì chúng ta sẽ tắt chương trình kiểm thử.\nVào trong tab Activity của ASG và chờ ASG huỷ các instance không còn cần thiết nữa, quá trình này có thể sẽ khá lâu.\nKết luận Khi ASG nhận thấy được là hệ thống đang có dấu hiệu quá tải từ một hoặc nhiều thông số nào đó, thì nó sẽ tiến hành khởi tạo thêm một hoặc nhiều instance để cho hệ thống trở về trạng thái ổn định. Nhưng dynamic scaling sẽ không được nhanh cho lắm bởi vì như mình đã nói ở trên, khi các chính sách scaling được tạo ra thì nó sẽ ảnh hưởng, tới các thông số gốc, từ đó ASG sẽ \u0026ldquo;nhìn\u0026rdquo; vào đó mà lựa chọn việc mở rộng hoặc thu gọn.\nNên số lượng các instance sẽ được tính toán và cập nhật lại cũng không được nhanh cho lắm. Với vấn đề này thì chúng ta sẽ có một giải pháp khác đi kèm là Predictive Scaling, để khi đó ASG sẽ phản ứng nhanh hơn.\n"
},
{
	"uri": "/vi/3-create-launch-template/",
	"title": "Tạo Launch Template",
	"tags": [],
	"description": "",
	"content": "AMIs và Launch Template AMIs (Amazon Machine Images) lưu trữ các thông tin như hệ điều hành, ứng dụng, cài đặt ở EC2 mà chúng được tạo. Việc tạo ra AMI đảm bảo rằng khi máy chủ mới được tạo ra thì nó được mọi máy chủ mới đều giống nhau và có thể hoạt động ngay lập tức\nLaunch template là một công cụ mà chúng ta dùng để cấu hình cho việc khởi tạo các EC2 mới thông AMI được gắn, loại instance, cấu hình mạng, và các tuỳ chọn bảo mật. Khi chúng ta muốn khởi tạo một hoặc nhiều máy chủ giống nhau, chúng ta chỉ cần sử dụng launch template đã được cấu hình để thực hiện việc này.\nThiết lập Launch Templates Tạo Amazon Machine Images (AMIs) từ EC2 Ở trong phần giao diện quản lý EC2, ở bảng chọn bên phải\nChọn Instances Chọn FCJ-Management instance Chọn Actions Chọn Image and templates Ấn Create image Trong bảng cấu hình cho Create AMI, chúng ta tiến hành điền các thông tin sau\nImage name FCJ-Management-AMI Image description AMI for FCJ-Management Ấn Create Image Sau khi tạo AMI chúng ta sẽ kiểm tra AMI vừa tạo\nChọn AMIs chúng ta sẽ thấy AMI vừa tạo được Chọn FCJ-Management-AMI Quá trình khởi tạo AMI sẽ mất khoảng 3 phút, sau quá trình khởi tạo chúng ta sẽ thấy Status của AMI chuyển từ trạng Available\nChúng ta vừa hoàn thành tạo một Image để lưu cấu hình của EC2\nTạo Launch Templates Ở giao diện quản lý EC2, ở bảng chọn bên phải\nChọn Launch Templates Chọn Create lkunch template Ở trong bảng Create launch template hãy điền các thông tin sau\nỞ phần Launch template name and description Launch template name FCJ-Management-template Template version description Template for FCJ Management Ở phần Application and OS Image (Amazon Machine Image) Chọn My AMIs Chọn Owned by me Chọn loại Amazon Machine Image (AMI), chọn AMI đã tạo FCJ-Management-AMI Ở phần Instance type Chọn loại Instance t2.micro Ở phần Key pair (logic) Chọn Key pair name có tên là fcj-key Ở phần Network settings Chọn subnet public AutoScaling-Lab-public-ap-southeast-1a Chọn Select existing security group Chọn security group FCJ-Management-SG Cuối cùng, chọn Create launch template Kết quả Kiểm tra Launch Template vừa tạo\nChọn FCJ-Management-template Ở đây chúng ta có thể xem lại cấu hình Launch Template chúng ta đã tạo Chúng ta vừa hoàn thành tạo Launch Template.\n"
},
{
	"uri": "/vi/2-preparation/2.4-add-data-to-db/",
	"title": "Cài đặt dữ liệu cho Database",
	"tags": [],
	"description": "",
	"content": "Lấy Public IP address của EC2 instance\nSử dụng MobaXterm để kết nối SSH vào instance qua port 22.\nChọn Session Chọn SSH Remote host, nhập Public IPv4 address mới lấy của instance Specify username, nhập ec2-user Kiểm tra port 22 Chọn Advanced SSH settings Chọn Use private key và chọn keypair của instance. Chọn OK Kết quả sau khi SSH\nChúng ta sử dụng git để clone source code. Trước hết, cài đặt git bằng lệnh sau:\nsudo yum install git Cài đặt MySQL command-line client\nsudo dnf install mariadb105 Kiểm tra cài đặt thành công\nmysql --version Kết nối MySQL command-line client (unencrypted)\nĐối với tham số -h, hãy thay thế DNS name (endpoint) cho DB instance, bạn có thể lấy DNS name ở trong console chi tiết của RDS bạn đã tạo - Đối với tham số -P, hãy thay thế port cho DB instance. (3306) Đối với tham số -u, thay bằng master user lúc bạn tạo RDS Sau khi chạy lệnh thì nhập vào master user password mà bạn đã đặt khi tạo RDS mysql -h fcj-management-db-instance.cdysiiecu90g.ap-southeast-1.rds.amzonaws.com -P 3306 -u admin -p Kết nối DB instance thành công. Tiến hành kiểm tra các database trong instance bằng lệnh sau sẽ in ra danh sách tất cả các cơ sở dữ liệu.\nSHOW DATABASES; Chọn cơ sở dữ liệu để thực hiện các thay đổi đối với nó bằng cách sử dụng USE, hãy dùng initial database lúc bạn tạo RDS .\nUSE \u0026#34;tên database\u0026#34;; Thực hiện tạo bảng trong database awsuser bằng lệnh CREATE TABLE.\nCREATE TABLE `awsfcjuser`.`user` ( `id` INT NOT NULL AUTO_INCREMENT , `first_name` VARCHAR(45) NOT NULL , `last_name` VARCHAR(45) NOT NULL , `email` VARCHAR(45) NOT NULL , `phone` VARCHAR(45) NOT NULL , `comments` TEXT NOT NULL , `status` VARCHAR(10) NOT NULL DEFAULT \u0026#39;active\u0026#39; , PRIMARY KEY (`id`)) ENGINE = InnoDB; Chèn thông tin vào trong bảng dữ liệu bằng lệnh INSERT INTO\nINSERT INTO `user` (`id`, `first_name`, `last_name`, `email`, `phone`, `comments`, `status`) VALUES (NULL, \u0026#39;Amanda\u0026#39;, \u0026#39;Nunes\u0026#39;, \u0026#39;anunes@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Alexander\u0026#39;, \u0026#39;Volkanovski\u0026#39;, \u0026#39;avolkanovski@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Khabib\u0026#39;, \u0026#39;Nurmagomedov\u0026#39;, \u0026#39;knurmagomedov@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Kamaru\u0026#39;, \u0026#39;Usman\u0026#39;, \u0026#39;kusman@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Israel\u0026#39;, \u0026#39;Adesanya\u0026#39;, \u0026#39;iadesanya@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Henry\u0026#39;, \u0026#39;Cejudo\u0026#39;, \u0026#39;hcejudo@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Valentina\u0026#39;, \u0026#39;Shevchenko\u0026#39;, \u0026#39;vshevchenko@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Tyron\u0026#39;, \u0026#39;Woodley\u0026#39;, \u0026#39;twoodley@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Rose\u0026#39;, \u0026#39;Namajunas \u0026#39;, \u0026#39;rnamajunas@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Tony\u0026#39;, \u0026#39;Ferguson \u0026#39;, \u0026#39;tferguson@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Jorge\u0026#39;, \u0026#39;Masvidal \u0026#39;, \u0026#39;jmasvidal@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Nate\u0026#39;, \u0026#39;Diaz \u0026#39;, \u0026#39;ndiaz@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Conor\u0026#39;, \u0026#39;McGregor \u0026#39;, \u0026#39;cmcGregor@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Cris\u0026#39;, \u0026#39;Cyborg \u0026#39;, \u0026#39;ccyborg@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Tecia\u0026#39;, \u0026#39;Torres \u0026#39;, \u0026#39;ttorres@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Ronda\u0026#39;, \u0026#39;Rousey \u0026#39;, \u0026#39;rrousey@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Holly\u0026#39;, \u0026#39;Holm \u0026#39;, \u0026#39;hholm@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;), (NULL, \u0026#39;Joanna\u0026#39;, \u0026#39;Jedrzejczyk \u0026#39;, \u0026#39;jjedrzejczyk@ufc.com\u0026#39;, \u0026#39;012345 678910\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;active\u0026#39;); Sử dụng lệnh SELECT để hiển thị bảng:\nSELECT * FROM user; Sử dụng exit đề rời khỏi. Nếu không thể ngắt kết nối với DB instance, hãy dùng tổ hợp phím Ctrl+C\n"
},
{
	"uri": "/vi/7-test-solutions/7.4-test-predictive-scaling-solution/",
	"title": "Đọc metrics của giải pháp predictive scaling",
	"tags": [],
	"description": "",
	"content": "Predictive Scaling Từ những lượng truy cập, công việc mà hệ thống mà chúng ta sẽ nhận và gửi đi mỗi ngày, thì ASG có thể \u0026ldquo;dự đoán\u0026rdquo; được lượng truy cập, công việc đó trong khoảng nhiều ngày tới, từ đó giúp cho ASG sẽ phản ứng tốt hơn trong việc khởi tạo và huỷ các instances đi. Thông thường thì Predictive Scaling sẽ dược dùng với các loại scaling khác.\nTiến hành cấu hình Giống ở phần trước, thì mình vẫn sẽ thực hiện scale in thủ công với ASG và chờ cho ASG xoá hết các instances mà dịch vụ này đã tạo.\nSau đó là xoá đi chính sách scaling tự động để tránh việc ảnh hưởng tới phần test này.\nTiếp theo, vào trong tab Activity, kéo xuống phần Predictive scaling policies và ấn Create predictive policy để tạo mới.\nTrong biểu mẫu này, chúng ta sẽ cấu hình như sau:\nPolicy details Name: PredictCPUUtilizationAt15Percent (có thể đặt tên bất kì) Turn on scaling: bật Scale based on forecast. Với chính sách scaling mang tính dự đoán, thì về bản chất là nó chỉ có dự đoán, nhưng mà chúng ta cũng có thể dùng nó để khởi tạo các instances. Tiếp theo, trong phần Metric and target utilization\nMetrics: chọn Custom metric pair. Load metric: chọn Custom CloudWatch metric. Scaling metric: chọn Custom CloudWatch metric. Các bạn sẽ thêm các custom metric json như sau\nVới Load metric { \u0026#34;CustomizedLoadMetricSpecification\u0026#34;: { \u0026#34;MetricDataQueries\u0026#34;: [ { \u0026#34;Label\u0026#34;: \u0026#34;Total CPU Utilization in ASG\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;cpu_sum\u0026#34;, \u0026#34;MetricStat\u0026#34;: { \u0026#34;Metric\u0026#34;: { \u0026#34;MetricName\u0026#34;: \u0026#34;WSCustomCPUUTILIZATION\u0026#34;, \u0026#34;Namespace\u0026#34;: \u0026#34;FCJ Management Custom Metrics\u0026#34;, \u0026#34;Dimensions\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;AutoScalingGroupName\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;FCJ-Management-ASG\u0026#34; } ] }, \u0026#34;Stat\u0026#34;: \u0026#34;Sum\u0026#34; }, \u0026#34;ReturnData\u0026#34;: true } ] } } Với Scaling metric { \u0026#34;CustomizedScalingMetricSpecification\u0026#34;: { \u0026#34;MetricDataQueries\u0026#34;: [ { \u0026#34;Label\u0026#34;: \u0026#34;Average CPU Utilization in ASG\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;cpu_avg\u0026#34;, \u0026#34;MetricStat\u0026#34;: { \u0026#34;Metric\u0026#34;: { \u0026#34;MetricName\u0026#34;: \u0026#34;WSCustomCPUUTILIZATION\u0026#34;, \u0026#34;Namespace\u0026#34;: \u0026#34;FCJ Management Custom Metrics\u0026#34;, \u0026#34;Dimensions\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;AutoScalingGroupName\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;FCJ-Management-ASG\u0026#34; } ] }, \u0026#34;Stat\u0026#34;: \u0026#34;Average\u0026#34; }, \u0026#34;ReturnData\u0026#34;: true } ] } } Tiếp theo là tích chọn Add custom capacity metric.\nVà tương tự như 2 bước ở trên, mình sẽ thêm custom metric json cho Capacity metric\n{ \u0026#34;CustomizedCapacityMetricSpecification\u0026#34;: { \u0026#34;MetricDataQueries\u0026#34;: [ { \u0026#34;Label\u0026#34;: \u0026#34;Number of instances in ASG\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;capacity_avg\u0026#34;, \u0026#34;MetricStat\u0026#34;: { \u0026#34;Metric\u0026#34;: { \u0026#34;MetricName\u0026#34;: \u0026#34;WSCustomGroupInstances\u0026#34;, \u0026#34;Namespace\u0026#34;: \u0026#34;FCJ Management Custom Metrics\u0026#34;, \u0026#34;Dimensions\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;AutoScalingGroupName\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;FCJ-Management-ASG\u0026#34; } ] }, \u0026#34;Stat\u0026#34;: \u0026#34;Average\u0026#34; }, \u0026#34;ReturnData\u0026#34;: true } ] } } Nếu như bạn có cấu hình ở bước 2.6 - Prepare metrics for predictive scaling trước đó, thì sau khi cấu hình xong, bạn sẽ thấy được 2 biểu đồ được hiển thị.\nỞ phần Pre-launch instances trong phần Additional scaling settings - optional, chỉnh xuống 1 minutes. Ấn Create để tạo.\nGiống với Dynamic, thì thông số Pre-launch instances này cũng sẽ ảnh hưởng tới thời điểm mà các instances sẽ được khởi tạo. Ví dụ như ASG dự đoán là lúc 23:00 giờ cao điểm, thì ASG sẽ dựa vào thông số này và tạo instance vào lúc 22:59 phút, theo như cấu hình.\nKiểm tra lại kết quả\nĐọc metric từ dữ liệu mẫu Vào trong chính sách đó, chúng ta sẽ đọc được 2 biểu đồ là Load và Capacity. Biểu đồ này cung cấp cho chúng ta về dữ liệu của các lưu lượng cũng như là số các instance đã dùng trong các ngày trước đó, từ đó thì nó đưa ra được dự đoán của các ngày tiếp theo, đươc biểu diễn bằng đường màu tím.\nBiểu đồ được lấy theo giờ UTC + 0, và chúng ta đang ở múi giờ +7 nên chúng ta sẽ cần phải thêm 7 khi đọc các biểu đồ này.\nTrước tiên, tập chung vào biểu đồ ở bên trái trước, vào thời điểm 15:00 (theo giờ của Việt Nam là 22:00) thì lượng chịu tải tổng là 164.546.\nVà để hiểu được thông số trên là của cái gì thì chúng ta nhìn qua biểu đồ bên phải.\nChúng ta có thể thấy là vào thời điểm đó thì dự đoán sẽ có 13 instance được khởi tạo, và lượng tải dữ liệu kia sẽ tương ứng với số các instance đó.\nChúng ta có thể xem các thời điểm khác.\nNếu bạn có thể chờ được thời điểm được dự báo, thì vào trong phần tab Activity của ASG, chúng ta sẽ thấy được là ASG khởi tạo một instance mới vào lúc 21:59, 1 phút trước thời điểm 22:00 như đã dự đoán ở trên.\nKết luận Chúng ta có thể kết hợp Predictive scaling với Dynamic scaling hoặc là các loại scaling khác để tăng độ linh hoạt cho ASG cũng như là độ tin cậy của hệ thống. Hệ thống nào cho lượng tải đồng đều theo thời gian thì sử dụng predictive để dự đoán cũng rất hợp lý.\n"
},
{
	"uri": "/vi/4-setup-load-balancer/",
	"title": "Thiết lập Load Balancer",
	"tags": [],
	"description": "",
	"content": "Load Balancer Load Balancer là một bước quan trọng để đảm bảo tính khả dụng và khả năng mở rộng cao cho ứng dụng của bạn. Cân bằng tải phân phối lưu lượng truy cập đến trên nhiều mục tiêu, chẳng hạn như phiên bản EC2, vùng chứa hoặc địa chỉ IP, giúp tối ưu hóa việc sử dụng tài nguyên, cải thiện hiệu suất và đảm bảo khả năng chịu lỗi.\nNội dung Tạo Target Group Tạo Load Balancer "
},
{
	"uri": "/vi/5-test/",
	"title": "Kiểm tra kết quả",
	"tags": [],
	"description": "",
	"content": "Kiểm tra kết quả Sau khi triển khai xong Load Balancer, thì chúng ta sẽ lấy DNS name của LB này và dán vào trong trình duyệt để thử kết quả của triển khai.\nVà đây là kết quả\nGiờ thì chúng ta sẽ thao tác một số thứ để kiểm tra xem hệ thống hoạt động ổn định hay không. Thử thay đổi thông tin của 1 record.\nKhi nhập xong thì chúng ta ấn Submit và nhận được thông báo.\nTrở lại trang chủ và nhận được kết quả là\nỞ các bước kiểm thử ở sau, thì chúng ta sẽ đọc các metrics là chính, nhưng bạn cũng có thể vừa đọc và vừa kiểm tra xem là ứng dụng có bị chậm trong quá trình kiểm thử hay không.\n"
},
{
	"uri": "/vi/2-preparation/2.5-deploy-web-server/",
	"title": "Triển khai máy chủ web",
	"tags": [],
	"description": "",
	"content": "Cài đặt node version manager (nvm) bằng cách nhập nội dung sau:\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash Sử dụng nvm để cài đặt Node.js bằng cách nhập nội dung sau vào dòng lệnh.\nnvm install 20 Thực hiện clone repository code ứng dụng\ngit clone https://github.com/First-Cloud-Journey/000004-EC2.git Đến thư mục của bài lab 000004-EC2\ncd 000004-EC2 NPM là viết tắt của Node package manager là một công cụ tạo và quản lý các thư viện lập trình Javascript cho Node.js. Sử dụng npm init khởi tạo project sẽ tạo ra file package.json mẫu.\nnpm init Cài đặt pm2 trong Global, PM2 được sử dụng để quản lý và giám sát các ứng dụng Node.js đang chạy. Nó cho phép các ứng dụng chạy dưới nền.\nnpm install -g pm2 Tiếp theo, chúng ta định nghĩa lại câu script để chạy ứng dụng, chúng ta sẽ dùng vim để mở file pakage.json, trong phần scripts ở key start, gán cho nó value sau, điều này sẽ giúp ứng dụng của chúng ta chạy nền:\npm2 start app.js Tiếp tục dùng vim để vào file .env, sau đó nhập vào nội dung sau để thiết lập kết nối tới database.\nDB_HOST=\u0026#39;fcj-management-db-instance.cdysiiecu90g.ap-southeast-1.rds.amzonaws.com\u0026#39; DB_NAME=\u0026#39;awsfcjuser\u0026#39; DB_USER=\u0026#39;admin\u0026#39; DB_PASS=\u0026#39;123Vodanhphai\u0026#39; Tiến hành khởi chạy ứng dụng:\nnpm start Lệnh pm2 status trong PM2 được sử dụng để hiển thị trạng thái hiện tại của tất cả các ứng dụng đang được quản lý bởi PM2. Khi bạn chạy lệnh này, chúng ta sẽ nhận được thông tin tổng quan về từng ứng dụng.\nTiếp theo, chúng ta cần lấy được public DNS của instance để có thể truy cập được ứng dụng từ trình duyệt.\nỨng dụng của chúng ta đã chạy ổn định.\nTiếp theo chúng ta dùng câu lệnh pm2 startup để tiến hành cấu hình PM2 tự động khởi động lại các ứng dụng khi máy chủ khởi động lại. Nó sẽ yêu cầu thiết lập Startup Script, hãy copy/paste command đó và chạy.\nĐể đảm bảo các ứng dụng đang chạy được lưu lại và khởi động lại khi server khởi động lại, chúng ta cần chạy lệnh pm2 save. Lệnh này sẽ lưu trạng thái hiện tại của các tiến trình vào danh sách khởi động.\n"
},
{
	"uri": "/vi/2-preparation/2.6-prepare-metrics-for-predictive-scaling/",
	"title": "Chuẩn bị các metric cho Predictive scaling",
	"tags": [],
	"description": "",
	"content": "Chuẩn bị dữ liệu cho Predictive scaling Bởi vì Predictive scaling cần phải có một lượng dữ liệu trong vòng hơn 2 ngày để có thể đưa ra được các dự đoán vào các ngày tiếp theo, mà ở đây chúng ta lại không có các dữ liệu đó cho nên là chúng ta sẽ cần phải chuẩn bị để giải lập một môi trường như thế.\nCác bước chuẩn bị Đầu tên là chúng ta sẽ tạo một folder mới với tên là metric-preparation và chuyển vào trong thư mục này\nmkdir metric-preparation \u0026amp;\u0026amp; cd metric-preparation Sau đó là tải kịch bản để chuẩn bị các dữ liệu\ncurl -o prepare-metric-data.sh https://raw.githubusercontent.com/awslabs/ec2-spot-workshops/master/workshops/efficient-and-resilient-ec2-auto-scaling/prepare-metric-data.sh Sau khi tải xong thì vào trong để thay đổi phần câu lệnh trong kịch bản này lại một xíu\nvim prepare-metric-data.sh Sau khi chỉnh sửa xong thì giờ chúng ta tiến hành tải các dữ liệu chưa qua xử lý, đó là lý do vì sao mà chúng ta cần tải kịch bản xử lý dữ liệu này trước. Trước tiên là metric cho các instances.\ncurl -o metric-cpu.json https://raw.githubusercontent.com/awslabs/ec2-spot-workshops/master/workshops/efficient-and-resilient-ec2-auto-scaling/metric-cpu.json Tiếp theo là dữ liệu cho CPU\ncurl -o metric-cpu.json https://raw.githubusercontent.com/awslabs/ec2-spot-workshops/master/workshops/efficient-and-resilient-ec2-auto-scaling/metric-cpu.json Tiến hành sửa đổi lần lượt 2 loại dữ liệu này, đầu tiên là cho CPU trước\nbash prepare-metric-data.sh metric-cpu.json FCJ-Management-ASG \u0026amp;\u0026amp; cat metric-cpu.json Tiếp theo là cho instances\nbash prepare-metric-data.sh metric-instances.json FCJ-Management-ASG \u0026amp;\u0026amp; cat metric-instances.json Ở 2 lệnh ở trên đều xuất hiện tham số FCJ-Management-ASG thì nó chính là tên của Auto Scaling Group mà chúng ta sẽ tạo về sau, nên về sau thì bạn cần sẽ phải tạo ASG với cùng tên như thế. Còn không thì bạn nên thay một cái tên khác từ bây giờ.\nTải dữ liệu lên CloudWatch Trong Amazon Linux 2023, và dùng đúng AMI thì AWS CLI đã được cài đặt sẵn ở bên trong, lúc này thì chúng ta chỉ cần lấy ra để cấu hình lại các crediential là được. Nên nhớ là bạn phải có một IAM User đủ quyền để tải dữ liệu lên CloudWatch hoặc ít nhất là đủ quyền để làm bài workshop này.\nVào trang IAM, vào thông tin IAM User và ấy Access Key Id và Serect Access Key, nếu chưa có thì tạo mới.\naws configure Và tiến hành cấu hình\nSau đó là tải 2 file dữ liệu mà chúng ta đã chuẩn bị trước đó lên trên CloudWatch\naws cloudwatch put-metric-data --namespace \u0026#39;FCJ Management Custom Metrics\u0026#39; --metric-data file://metric-cpu.json aws cloudwatch put-metric-data --namespace \u0026#39;FCJ Management Custom Metrics\u0026#39; --metric-data file://metric-instances.json Kiểm tra Cuối cùng thì chúng ta sẽ vào trong CloudWatch để kiểm tra kết quả\nTìm CloudWatch Click để vào trong CloudWatch Console Trong giao diện Console của CloudWatch\nChọn All metrics Chọn FCJ Management Custom Metrics Chọn tiếp AutoScalingGroupName\nChọn tiếp 2 thông số như trên hình, chờ một khoảng thời gian để nhận được kết quả.\nChúng ta sẽ phải chờ khoảng 30 phút hoặc hơn để cho CloudWatch xử lý xong. Thay vì chờ thì chúng ta nên làm tiếp các phần tiếp theo.\n"
},
{
	"uri": "/vi/6-create-auto-scaling-group/",
	"title": "Tạo Auto Scaling Group",
	"tags": [],
	"description": "",
	"content": "Vấn đề ở phần trước Ở phần kiểm thử kết quả ở bên trên, thì chúng ta có thể thấy là khi ứng dụng có nhiều request tới thì nó sẽ hoạt động không còn ổn định nữa và giải pháp là chúng ta sẽ phải tăng thêm nhiều EC2 Instance ở trong hệ thống và nhờ vào Load Balancer để chia sẻ các yêu cầu từ phía người dùng.\nTuy nhiên tới phương pháp thủ công này thì sẽ không được hợp lý cho lắm, bởi vì để khởi tạo một EC2 Instance, thì mình cần phải có được cái \u0026ldquo;lõi\u0026rdquo; ở bên trong, chính là ứng dụng đang đảm nhận nhiệm vụ xử lý các yêu cầu đó và cùng với các thư viện khác.\nThiết lập Auto Scaling Group Thiết lập Launch template Ở trong giao diện quản lý của EC2, kéo bảng lựa chọn ở bên phải xuống cuối cùng.\nChọn Auto Scaling Groups. Ấn Create Auto Scaling group. Ở trong giao diện tạo Auto Scaling group, chúng ta sẽ điền các thông tin sau\nName: FCJ-Management-ASG Trong Launch template: Launch template: chọn FCJ-Management-template (có thể là bất kỳ cái tên nào). Version: Default (1) theo như lựa chọn mặc định. Lưu ý là tên của ASG bạn nên đặt đúng với tên của ASG mà được đặt ở trong phần 2.6 trước đó, bước chuẩn bị dữ liệu cho Predictive Scaling.\nLaunch template được chọn cho ASG phải là template mà được cài đặt đầy đủ MySQL Client, Node, Source Code và PM2 thì mới đảm bảo các Target hoạt động bình thường, nếu như bạn làm theo các bướcr trong phần 2 và phần 3 thì bạn đã làm đúng.\nThiết lập mạng Ở trong phần Network, chọn các thông tin như sau:\nVPC: chọn VPC AutoScaling-Lab, VPC mà chúng ta đã tạo ở đầu bài. Availability Zones and subnets: chọn 3 public subnets mà chúng ta đã tạo. Ấn Next. Thiết lập Load Balancer và một số thứ khác Ở trước đó thì chúng ta đã có tạo Application Load Balancer và tạo một Target Group và gắn vào trong bộ cân bằng tải đó. Nên giờ chúng ta sẽ chọn một số lựa chọn như sau:\nLoad balancing: chọn Attach to an existing load balancer. Attach to an existing load balancer: chọn Choose from your load balancer target group Existing load balancer target group: chọn FCJ-Management-TG | HTTP. Khi cấu hình đúng Target Group và Application Load Balancer, thì ở lựa chọn Existing load balancer target group chúng ta có thể thấy được Target Group đó được liệt kê, nghĩa là cả ALB và TG đều tồn tại.\nTrong phần VPC Lattice integration options: chọn No VPC Lattice service, trong bài này thì chúng ta không cấu hình phần này.\nTiếp theo là Health checks, chúng ta sẽ chọn (tích) Turn on Elastic Load Balancing health checks. Để các thiết lập còn lại theo mặc định.\nTrong phần Additional settings, ở phần Monitoring:\nChọn (tích) Enable group metrics collection within CloudWatch. Ấn Next. Thiết lập Size và Scaling cho Group Ở trong phần này thì mình sẽ xác định các hành vi mở rộng của Group và số lượng các Instance sẽ được khởi tạo trong quá trình Scale, bao gồm Scale out (mở rộng) và Scale in (thu hẹp).\nTrong phần Group size: Desired capacity: 1 Trong phần Scaling: Scaling limits: Min desired capacity: 1 Max desired capacity: 3 Trong Automatic scaling - optional: chọn No scaling policies, tạm thời làm mình sẽ không thiết lập chính sách scaling cho ASG.\nTrong Instance maintenace policy: chọn No policy.\nỞ đây chúng ta sẽ không thiết lập chính sách cho ASG là vì mình sẽ thực hiện các chiến lược Scaling sau, bao gồm 4 chiến lược khác nhau.\nThiết lập thông báo Trong phần này, chúng ta sẽ thiết lập thông báo tới email (dùng Amazon SNS) khi mà ASG:\nKhởi tạo một Instance mới. Huỷ một Instance. Thất bại khi khởi tạo Instance. Thất bại khi huỷ một instance. Chúng ta sẽ chỉ tạo thông báo tới một email duy nhất, bao gồm các thông tin:\nSend a notification to: asg-topic. Mình sẽ chọn một topic để gửi. With these recipents: nhập email mà bạn muốn SNS gửi tới. Event types: chọn tất cả. Ấn Next. Xác nhận lại các thông tin và Create Auto Scaling group.\nKết quả Trong quá trình tạo thì sẽ có một email gửi tới, nhớ kiểm tra và đăng ký nhận email từ topic đó.\nVì ở trên chúng ta chỉnh thông số Desired capacity = 1, nên khi được tạo ra thì ASG sẽ tự động tạo cho hệ thống một Instance mới, lúc này thì chúng ta sẽ nhận được email mới.\nVào trong tab Activity của ASG FCJ-Management-ASG để kiểm tra\nTrong quá trình thực hiện các chiến lược scaling khác, bạn có thể sẽ nhận được rất nhiều email, nên hãy chú ý trong Email Box. Đây cũng là chủ đích khi chúng ta tạo SNS để thông báo, nhắm dễ kiểm soát được điều gì đang diễn ra hơn.\n"
},
{
	"uri": "/vi/7-test-solutions/",
	"title": "Kiểm thử các giải pháp",
	"tags": [],
	"description": "",
	"content": "Các giải pháp / kỹ thuật scaling Dịch vụ Auto Scaling Group cung cấp cho mình các giải pháp scaling khác nhau, tuỳ thuộc vào nhu cầu và mức độ sử dụng hệ thống của chúng ta. Vì thề mà chúng ta cần phải tính toán, ước lượng, quan sát và lập kế hoạch sử dụng cho từng loại hoặc là kết hợp các loại với nhau để tăng độ linh hoạt của hệ thống.\nTrong phần này thì chúng ta sẽ đi thử từng giải pháp, nhưng trước khi đi vào từng giải pháp thì chúng ta hãy cũng tìm hiểu sơ về các giải pháp scaling này.\nManual scaling Chúng ta thực hiện mở rộng hay thu hẹp các target trong một Target Group bằng cách là điều chỉnh thông số Desired capacity trong Auto Scaling Group, thì hành động này được gọi là Manual Scaling. Trong một số tình huống đơn lẻ, nhanh, thì chúng ta cần sẽ phải thực hiện việc thêm và bớt các targets thủ công.\nScheduled scaling Khi mà chúng ta nắm rõ được lưu lượng mạng vào và ra của hệ thống hoặc là thời điểm mà các target hoạt động ở công suất gần như là cao nhất, và hoạt động này diễn ra liên tục và mang tính dài hạng (có thể là hàng năm) thì mình có thể đặt lịch (và cả hẹn giờ) để cho Auto Scaling Group thực hiện việc mở rộng và thu gọn các targets.\nDynamic scaling Ngoài ra nếu như lưu lượng mạng đi vào hệ thống không diễn ra theo một trật tự nào và khó đoán thì chúng ta có thể dùng giải pháp tự động scaling của ASG. Khi đó thì ASG sẽ dựa vào cấu hình Dynamic scalang policy để triển khai việc mở rộng và thu gọn các targets cho phù hợp hơn với hệ thống.\nPredictive scaling Còn một kỹ thuật khác nữa là ASG sẽ dự đoán các lưu lượng mạng trong vòng 3 hoặc nhiều ngày tới. Với những hệ thống khó đoán, thì chúng ta có thể dựa vào giải pháp này và Dynamic scaling để tăng tính linh hoạt cho hệ thống. Giải pháp này sẽ biểu diễn các thông số tuỳ vào việc mà mình cấu hình, nhưng ý tưởng chung vẫn là dữ đoán trước các lưu lượng, mức sử dụng trong hệ thống.\nVì khi thực hiện phần này thì chúng ta không có dữ liệu ở phần trước, nên đó là lý do mà chúng ta cần phải chuẩn bị và chạy dữ liệu mẫu ở phần 2.6 - Prepare metrics for predictive scaling trước đó.\nCài đặt chương trình kiểm thử Trước khi đi vào phần này, thì chúng ta cần phải tải một chương trình kiểm thử để có thể giải lập được hệ thống đang chịu tải ở lưu lượng cao. Đầu tiên, vào đường dẫn này để tải chương trình kiểm thử về: https://www.paessler.com/tools/webstress\nChúng ta sẽ tải về file Rar, vào trong file Rar đó trích xuất file cài đặt ở bên trong và cài đặt chương trình. Sau khi cài đặt xong thì chúng ta vào trong chương trình và thấy được giao diện như sau\nNội dung Kiểm thử giải pháp manual scaling Kiểm thử giải pháp scheduled scaling Kiểm thử giải pháp dynamic scaling Kiểm thử giải pháp predictive scaling Thời gian để làm phần này là rất lâu, và cần phải quan sát kỹ lưỡng (bạn có thể test trong quá trình chạy kiểm thử), nên bạn phải kiên nhẫn và kĩ lường để quan sát kết quả.\n"
},
{
	"uri": "/vi/8-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "Dọn dẹp tài nguyên Sau khi thực hành xong bài workshop chúng ta tiến hành bước dọn dẹp tài nguyên\nXóa Auto Scaling Group Ở giao diện quản lý EC2, ở thanh điều hướng bên trái, lướt xuống và chọn Auto Scaling Groups\nChọn Auto Scaling Groups FCJ-Management-ASG Nhấn vào nút Actions ở góc trên bên phải màn hình Chọn Delete Xóa Load Balancer: Ở giao diện quản lý EC2, ở thanh điều hướng bên trái, lướt xuống và chọn Load Balancer\nChọn Load Balancer FCJ-Management-LB Nhấn vào nút Actions ở góc trên bên phải màn hình Chọn Delete load balancer Xóa Target Group: Ở giao diện quản lý EC2, ở thanh điều hướng bên trái, lướt xuống và chọn Target Group\nChọn Target Group FCJ-Management-TG Nhấn vào nút Actions ở góc trên bên phải màn hình Chọn Delete Xóa Launch Template: Ở giao diện quản lý EC2, ở thanh điều hướng bên trái, lướt xuống và chọn Launch Templates\nChọn Launch Templates CJ-Management-TG Nhấn vào nút Actions ở góc trên bên phải màn hình Chọn Delete template Xóa AMI: Ở giao diện quản lý EC2, ở thanh điều hướng bên trái, lướt xuống và chọn AMIs\nChọn AMI FCJ-Management-AMI Nhấn vào nút Actions ở góc trên bên phải màn hình Chọn Deregister AMI. Terminate EC2 instance Ở giao diện quản lý EC2, ở thanh điều hướng bên trái, chọn Instance\nChọn FCJ-Management instance Nhấn vào nút Instance state ở góc trên bên phải màn hình Chọn Terminate (delete) instance Xóa RDS Database Truy cập RDS Trên thanh điều hướng bên trái, chọn Databases instance Chọn database instance fcj-management-db-instance liên quan tới bài lab. Nhấn vào Modify. Ở phần Modify DB Instance, chúng ta kéo xuống dưới cùng\nNhấp bỏ Enable deletion protection Nhấn Continue Tiếp tục ở phần Schedule modifications\nChọn Apply immediately Nhấn Modify DB instance Tiến hành xoá DB instance\nChọn database instance fcj-management-db-instance Nhấn vào nút Actions ở góc trên bên phải màn hình Chọn Delete Chọn I acknowledge that upon instance deletion, automated, including system snapshots and point -in-time recovery, will no longer be available Điền delete me Nhấn Delete Xóa Subnet Group Chọn Subnet groups Chọn subnet group fcj-management-subnet-group Chọn Delete "
},
{
	"uri": "/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]